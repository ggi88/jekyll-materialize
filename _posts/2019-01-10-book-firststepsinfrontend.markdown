---
layout: post
title:  "[book] 프론트엔드 개발 첫걸음"
date:   2019-01-10 00:00:00
categories: book
published: true
---

0. TOC
{:toc}


### 참고
  
- 책 예제 코드: https://github.com/okachijs/jsframeworkbook

### 자바스크립트 프론트엔드 개발 프레임워크의 최신 동향

#### 프레임워크의 발전

##### 프레임 워크란 무엇인가

- 프레임워크 vs 라이브러리
  - 라이브러리: 프로그램에서 필요로하는 기능을 제 3자가 사용할 수 있는 형태로 모아둔 것
  - 프레임워크: 애플리케이션의 전체 옥은 일부분의 형태를 규정 혹은 방침화한 것

- SPA(Single Page Application)
  - 브라우저 및 브라우저 렌더링 엔진 내부에서 동작하는 웹 애플리케이션
  - 프라우저에서 최초 접근한 URL을 기점으로 하여 다양한 화면으로 이동을 제공하지만 기본적으로 최초의 JTML 안에서 사용자 인터페이스가 완결됨
  - 페이지 내의 사용자 인터페이스 변화에 따라 URL이 순차적으로 변화하며, 브라우저 히스토리를 통해 앞의 페이지로 거슬러 올라갈 수 있음
  - 페이지에서 필요로 하는 데이터는 서버로부터 API등의 형태로 필요할 때마다 단편적으로 제공됨

##### React

- 사용자의 조작에 따라 사용자 인터페이스가 동적으로 변화하는 웹 애플리케이션을 개발할 수 있게 해주는 프론트엔드 라이브러리
- A JavaScript libarary fpr building user interfaces

##### Angular

- 강력한 명형행 도구와 잘 정돈된 폴더 구조, 프로젝트 생성과 동시에 각종 환경이 한번에 갖춰지는 등 필요한 기능을 모두 내장한 프론트엔드 프레임워크
- Angular CLI 명령행 도구
- 내부적으로 RxJS 사용됨

##### Vue.js

- 라이브러리적 측면과 프레임워크적인 측면을 동시에 갖는 프레임워크(프로그레시브 프레임워크)
- React처럼 가상DOM을 가지면서도 React만큼 템플릿이 자바스크립트와 밀접하게 결합하지 않는다
- 단일 파일 컴포넌트 스타일
- Vue CLI 지원

##### React Native

- React의 기술을 기반으로 모바일용 네이티브 애플리케이션을 개발하는 프레임워크
- iOS, 안드로이드 모두 지원하는 애플리케이션 개발
- 네이티브 컴포넌트를 React의 JSX로 추상화하는 방식을 취함
- A framework for building native apps with React

### SPA 와 WPA

#### 클라이언트 사이드 라우팅

- URL 마다 화면을 만들어두거나 HTML5의 히스토리 API로 이전 버튼을 사용할 수 있게끔 해야한다.

##### CSS in JS

- 자바스크립트가 CSS 내장
- 여러 라이브러리에서 다른 작성법을 지원하지만 최종적으로 CSS로 변환되어 HTML에 적용

##### 컴포넌트 지향

- 애플리케이션의 기본 정보를 포함하는 페이지를 통째로 하나의 컴포넌트로 정의(루트 컴포넌트)
- 루트 컴포넌트 안에 다른 컴포넌트를 포함시키는 형태로 컴포넌트 간의 부모 관계 및 형제 관계를 형성 및 상호작용을 정의
- 컴포넌트 지향 애플리케이션을 구현할 땐 컴포넌트 단독으로 필요한 기능을 수행할 수 있는 스타일과 스크립트가 존재해야하기 때문에 캡슐화 사용

##### SSR(server-side rendering)과 프리 렌더링

- 일반적인 웹 애플리케이션에선 사용자가 브라우저를 통해 접근하는 콘텐츠가 이미 삽입된 HTML을 응답으로 받아온다.
- SSR을 적용하면 서버에서 클라이언트로 전달되는 응답 결과에 이미 콘텐츠까지 렌더링을 마친 상태를 전달한다. 이를 구현하기 위해선 서버측에서 SPA에서 만들 렌더링 결과를 완성해야한다.
- 프리 렌더링은 요청이 들어왔을 때 대상이 크롤러인지 판단하여 크롤러인 경우 가상 브라우저로 접근하는 방식으로 생성한 다음 저장해둔 렌더링 결과를 제공하는 방식

##### 가상 DOM(Virtual DOM)

- 자바스크립트가 HTML을 렌더링하는 방법 중 하나이다. React에서 가상 DOM을 채택하고 주목받게 됨

##### 웹 애플리케이션의 MVC

- 뷰
    어떻게 외부에 출력할지를 정의하는 부분. 전달형태는 HTML일수도 있고 JSON일수도 있다.
- 컨트롤러
    URL 요청을 받을 때(라우팅) 필요에 따라 컨트롤러가 모델과 정보를 주고받은 다음 적절한 뷰를 골라 사용자에게 반환

##### 프론트엔드 애플리케이션의 MV

- 프론트엔드 애플리케이션에서 말하는 MV(Model-View)는 MVC 애플리케이션의 뷰 부분에 해당
- 웹 애플리케이션에선 본래 콘텐츠가 HTML에 포함된 채로 사용자에 응답을 주기 때문에 View안에 MV와 같은 구성을 할 필요가 없다. 그러나 SPA는 데이터 접근 계층이 추가되거나 URL을 요체하는 처리 등이 끼어들기에 필요하게 되었다.

##### MVP 패턴

- MV에 프리젠터(Presenter)가 추가된 패턴
- 모델과 뷰 사이에 프리젠터가 위치하여 양자 간의 입출력 인터페이스 역활을 맡는다.

### 자바스크립트 프론트엔드 개발을 위한 기초 지식 및 환경 구축

#### 자바스크립트 프론트엔드 개발을 위한 환경구축

##### Node.js 설치

- Node.js 설치: nvm or n 이용
- npm: -g, i, un
- package.json 버전 지정
  - major
    하위 호환성이 깨질 떄 숫자 올라감
  - minor
    하위 호환성이 유지되면서 새 기능이 추가될 대 숫자가 올라감
  - patch
    버그 수정 등에 숫자가 올라감
  - version
    틸드(~): 지정한 버전의 아래 자리가 최신인 버전으로 업데이트
    캐럿(^): (하위 호환성 유지를 위해)  major 버전을 유지하고 그 이하 버전을 최신으로 업데이트
    x, *, " ": 와일드카드 문자, 해당하는 모든 버전 허용
- package-lock.json: 설치된 패키지의 이름과 정확한 버전 정보를 파일에 기재(의존성 정보)

##### 프론트엔드 빌드 도구

- 여러개의 파일로 된 CSS나 자바스크립트를 파일 간 의존관계를 해소하고 하나의 파일로 정리해주는 도구(모듈 번들러) → 파일 요청 횟수 줄어듬
- 엔트리
    엔트리는 webpack이 모듈의 이존관계를 해석하는 시작점
- 아웃풋
    번들된 내용을 출력할 파일, 절대 경로 정보를 확인하여 사용
- 로더
    webpack은 로더를 사용해서 자바스크립트 이외의 정적 파일도 번들링 할 수 있다.
    babel-lodaer(ECMAScript2015 이전 → ECMAScript2015), style-lodaer(동적으로 style 태그를 생성하여 css를 적용), css-loader(css파일 간의 의존관계를 해소).
    현재적인 자바스크립트 코드를 레거시 브라우저에서도 동작시킬 수 있고 css도 동시에 읽어 들일 수 있다.
- 플러그인
    로더는 각 개별 파일 수준에서 의존관계를 해소하거나 모듈 타입을 변환해주지만 플러그인을 사용하면 보다 폭넓은 작업을 할 수 있다.

##### 개발용 서버 구축하기

- webpack-dev-server
    contentBase: index.html이 위치한 /를 루트 디렉토리로 지정
    historyApiFallback: true 시 화면 이동 시에 새로운 URL이 만들어진다. 이렇게 하면 브라우저 이전버튼을 눌러도 404 에러 대신 화면이동을 거슬러 올라갈 수 있다.
- VSCode
    Debugging, ESLint

### 자바스크립트 프론트엔드 개발을 위한 기초 지식

#### ECMAScript 2015의 개요

- 자바스크립트는 ECMA 인터내셔널이라는 표준화 단체에서 표준 규격을 작성
- http://kangax.github.io/compat-table/es6/

##### 변수선언

- let: 값을 다시 대입할 수는 있지만 재선언이 안됨
- const: 재대입 및 재선언이 모두 불가능
- let과 const는 윺효범위가 해당 블록에 한정

##### 템플릿 리터럴

- 백틱(`)으로 감싼 템플릿 문자열에서 ${변수명}으로 해당 변수 참조

##### 디폴트 인자

- 인자를 지정하지 않는 경우 if문으로 초기화해줬지만 인자에 초기값을 사용할 수 있다.

##### 화살표함수

- function 예약어를 사용하지 않으며, (인자)와 {몸체} 정의 사이에 화살표가 들어간다
- 중괄호({}) 및 return문을 생략할 수 있는 경우는 다음과 같이 쓸 수도 있다.

##### this예약어와 bind

- bind를 정의한 지점의 this가 참조

##### 클래스 정의

- ECMAScript5 이전에는 클래스 정의가 없었기 때문에 프로토타입에 메소드를 추가하는 방식으로 사용했지만, ECMAScript 2015부터는 클래스 정의가 가능함.

##### 클래스 상속

- extends

##### 프로미스(Promise)

- pending(실행대기), 처리 성공(fulfilled), 처리 실패(rejected)
- .them(), .catch()

##### 모듈

- ECMAScript 2015부터 모듈 형태로 파일을 분할할 수 있다.

### TypeScript의 개요

- 마이크로소프트가 개발한 자바스크립트 기반 오픈소스 프로그래밍언어
- 정적 타이핑, 클래스 기반 객체 지향 등 기존의 자바스크립트에는 없었던 기능을 추가한 수퍼셋

##### TypeScript 컴파일러 "tsc"

- 어떤 프로그래밍 언어로 작성된 코드를 다른 프로그래밍 언어로 된 코드로 변환하는 것을 트랜스파일 이라고 한다.

##### 변수와 타입 어노테이션

- 변수명 : 타입명 = 값; 
- 변수의 타입을 지정하는 것을 타입 어노테이션 이라 한다.
- 타입 추론 가능

##### 타입 변환

- <변환후_타입> 변수 or 변수 as 변환후_타입
- any 타입
- JSX 를 사용할 때는 변수 as 변환후_타입 문법을 사용

##### 함수의 타입 어노테이션

- 인자는 인자명 옆에 콜론을 붙여 타입명을 기재
- 필수가 아닌 인자도 ?를 붙이면 생략 가능, 대신 오른쪽에 모아두어야한다.
- 콜백 함수의 타입 어노테이션은 (인자: 타입) => 반환값_타입 으로 => 오른쪽에 반환값의 타입이 오는데 비해, 화살표 함수에서는 (인자: 타입) 반환값_타입 => 처리내용 과 같이 => 오른쪽에는 함수의 처리 내용이 위치하므로 코드를 읽을 때 주의 필요

##### 인터페이스

- 객체의 타입을 정의하기 위한 방법, 인자로 받을 객체의 내용물까지 타입으로 정의하는 함수

##### 클래스

- public, private, protected 접근제어자
- 기본값이 public 이며, pricate는 클래스 외부에서 접근불가, protected 상속받은 클래스로 부터 접근 가능

##### 제너릭(Generic)

- 함수, 클래스, 인터페이스를 다양한 타입에서 재사용할 수 있는 기능
- 같은 일을 하는 함수를 타입마다 따로 만들 필요가 없다

##### 타입 정의 파일

- 정의한 타입을 별도 파일에 모아두는 기능 존재
- ts는 코드가 담긴 파일의 확장자, .d.ts는 타입정의 파일의 확장자

##### 데코레이터

- 디자인 패턴의 한 종류로 "클래스나 메서드를 장식(데코레이트) 한다" 는 의미
- 클래스와 메서드를 "장식"하여 기능이나 별도의 행동을 추가할 수 있다. TypeScript의 데코레이터는 클래스, 메서드, 액세서(accessor), 속성 및 파라미터에 적용이 가능

##### JSX

- 자바스크립트 임베드 시킬 수 있는 XML과 유사한 문법

### 자바 스크립트 프론트엔드 개발을 위한 서버 구축

#### 예제 어플리케이션 개요

- 채팅 서버가 제공하는 API를 사용하여 메시지를 주고 받는다.

##### 채팅 어플리케이션 사양

- 1.채널 바꾸기 2.채널의 메시지 목록 보기 3.채널에 메시지 보내기

##### 채팅 서버의 사양

- 1.채널 만들기 2.채널명 목록확인 3.채널의 메시지 목록 확인 4.특정 채널에 새 메시지 추가히가 5.초기 상태로 돌아가기

##### 채팅 서버의 RestfulAPI

- 채널 만들기
    POST /channels
- 채널명 목록 확인
    GET /channels
- 특정 채널에 새 메시지 추가하기
    POST channels/채널명/messages
- 채널의 메시지 목록 확인
    GET channels/채널명/messages
- 초기 상태로 돌아가기
    POST /reset

##### 채팅 서버의 구조

- Firebase
    구글이 만든 모바일 플랫폼. ISO, 안드로이, 웹 등에서 애플리케이션을 구축해서 모바일 서비스를 제공할 때 필요한 기능을 갖추고 있다. 주고 기능은 실시간 데이터베이스, 사용자 인증, 스토리지 호스트, 펑션, 노티피케이션 등

##### Firebase를 이용하여 채팅 서버 구축

- Firebase 실시간 데이터베이스
    클라우드 호스팅 타입의 NoSQL 데이터베이스이다.
    JSON 데이터를 저장 혹은 동기화 할 수 있다. 실시간 데이터베이스 SDK를 사용하면 실시간으로 데이터 저장 및 동기화가 가능하다.
- Firebase 클라우드 펑션
    이벤트나 HTTPS 요청을 트리거로 삼아 함수를 실행한다.
    Firevbase Admin SDK를 함게 사용하면 Firebase의 기능을 통합하거나 다른 서버와 연동할 수 있다.
- Firebase 호스팅
    SPA를 간단히 배포할 수 있다. CDN 및 HTTPS도 지원한다.
- Authentication
    사용자 인증 시스템을 간단히 구축할 수 있다. 이메일 주소, 전화인증, 구글, 트위터, 페이스북, 깃허브, 계정과 익명에 대한 로그인 프로바이더를 제공한다.

##### 개발 환경 준비하기

- firebase 사용시작하기
- firebase 프로젝트 만들기
- firebase cli 설치하기
- firebase cli 로 로그인하기
- firebase 프로젝트 초기화 하기: 호스팅 및 펑션 설정

### 채팅 서버의 RESTful API 구현

##### 관련 모듈 설치하기

##### 펑션 및 어드민 SDK 모듈 임포드 하기

- firebase-functions는 firebase 펑션 SDK인데, 여기서는 HTTP 요청을 일으키기 위해 사용한다. firebase-admin은 firebase 어드민 SDK로, 실시간 데이터베이스 처리 및 인증을 수행하기 위해 사용한다. admin.initalizeApp 부분에서 admin 인스터스를 초기화한다.

##### Express 모듈 임포트 및 인스턴스 생성

##### cors 모듈 임포트 및 인스터스 생성

##### 사용자 정보 알아내기

- Firebase를 사용하면 비교적 쉽게 사용자 인증 기능을 구현할 수 있다.
- 펑션 역시 인증을 거친 사용자만이 가질 수 있는 Access Token을 사용함으로써 실질적으로 사용자 검증이 가능하다. 인증을 마친 사용자의 사용자ID, 이름, 아바타 이미지 URL 정보를 얻는데 이 기능을 사용한다.

##### 채널 생성 API

##### Express 모듈 임포트 및 인스턴스 생성

##### cors 모듈 임포트 및 인스턴스 생성

##### 사용자 정보 알아내기

##### 채널 셍상 API

##### 채널 목록을 확인하는 API

##### 지정한 채널에 새 메시지를 추가하는 API

##### 채널 내 메시지 목록을 확인하는 API

##### 초기 상태로 되돌리기

### Slack 스타일의 예제를 만들어보며 React/Angular/Vue.js 익히기

#### React의 컴포넌트

- props와 state의 역활과 사용법 이해
- 컴포넌트 생애주기 관리

##### 컴포넌트

- constructor(): React 컴포넌트에서 state의 초기 상태를 설정하는데 사용, state는 컴포넌트의 렌더링과 관계된 값을 관리하는 상태
- handleInputChange(): state에 사용자의 조작을 반영하는 역활을 밭은 메소드, render() 나 componentDidMount()와 달리, 이름을 바꿔도됨
- handleInputChange()에는 폼에 입력된 내용을 state에 반영시키 위한 코드가 들어있다.
- componentDidMount()는 컴포넌트 생애주기와 관련된 메서드
- render()는 가상 DOM(VDOM)의 렌더링 처리를 담당하는 메서드
- React에선 통상적으로 HTML 렌더링에 JSX를 사용
- 클래스형 컴포넌트: React.Component의 하위 클래스 컴포넌트
- 함수형 컴포넌트: Preview처럼 함수 형태로 정의되는 컴포넌트

##### props 와 state

- props
    컴포넌트에 들어오는 입력을 말하며, 부모 컴포넌트에서 자식 컴포넌트로 전달된다.
    읽기만 가능하며 변경을 불가능
- state
    컴포넌트 자체의 상태, 상태 변경을 통해 외부 데이터 및 사용자의 상호작용을 컴포넌트에 반영

##### 컴포넌트의 생애주기

- 생애주기란 "컴포넌트가 마운트"되거나 "컴포넌트가 props를 전달받는" 것처럼 컴포넌트의 상태가 변화하는 것을 말한다. 생애주기와 관련된 메서드
- componentDidMount()
    컴포넌트가 마운트되었을 때 딱 한번 실행되는 메서드
    HTML 초기처리, 이벤트리스너 정의나 외부 HTTP 요청으로 데이터를 받아오는 처리를 호출하는 일 등

- componentWillUnmount()
    컴포넌트가 언마운트될 때 실행
    언마운트란 엔더링 되고 있는 컴포넌트가 (페이지 이동 등의 이유로) 렌더링 대상에서 빠질 대 일어난다.
    타이머 해제나 비동기통신 취소 처리를 실행하는데 적합, componentDidMount()에서 정의한 이벤트리스너를 해제하는 것도 여기에 작성

- componentWillReceiveProps()
    마운트된 컴포넌트가 새로운 props를 받을 때 실행
    새로 수신된 props를 인자로 받는다. props의 현재 내용과 새로 수신된 props의 내용을 비교한 결과로 분귀되는 처리를 수행할 수 있다.

- componentDidUpdate
    컴포넌트가 업데이트되었을 때 실행된다. 여기서 말하는 update란 props나 state를 말한다. 즉 props나 state가 업데이트 됨에 따라 (2번째 이후의) HTTP요청을 보낼때에는 componentDidUpdate()를 사용하는 것이 좋다.

- shouldComponentUpdate()
    shouldComponentUpdate() 재 렌더링 유무를 제어

- componentDidCatch
    React V16부터 새로 도입된 메서드, 자식 컴포넌트에서 발생한 에외를 catch한 경우 실행

#### 예제 react 개발 

##### 애플리케이션과 컴포넌트의 개요

- 라우팅 설정: URL 과 컴포넌트를 매칭시켜주는 라우팅에 대한 설정
- 채널 목록: 애플리케이션의 채널 목록을 관리하는 역활
- 채널 상세
    메시지 피드: 송신된 메시지 목록을 관리하는 컴포넌트
    메시지 폼: 새 메시지를 송신하는 역활을 담당하는 컴포넌트

##### 채널 목록 컴포넌트 구현하기

##### 라우팅 설정 컴포넌트 구현하기

##### GET 요청 구현하기

##### 




